<!DOCTYPE html>
<html lang="en">

<head>
  <title>My homepage</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="stylesheets/bootstrap.min.css" crossorigin="anonymous">
  <script src="javascripts/dist/jquery-3.2.1.slim.min.js" crossorigin="anonymous"></script>
  <script src="javascripts/dist/popper.min.js" crossorigin="anonymous"></script>
  <script src="javascripts/dist/bootstrap.min.js" crossorigin="anonymous"></script>
  <div id="back" class="back"></div>
  <div class="card card-profile text-center">
    <img class="card-img-top" src="images/blockchain_small.jpeg" />
    <div class="card-block">
      <img class="card-img-profile" src="images/kevin_2.jpg?size=80" />
      <h4 class="card-title">
        Kevin Decoster
        <small>DevOps & Blockchain Analyst at </small>
        <small> <a href="https://atonra.ch">Atonra Partners SA</a></small>
      </h4>
      <div class="card-links">
        <a class="fa fa-linkedin" href="https://www.linkedin.com/in/kevin-decoster"></a>
        <a class="fa fa-gitlab" href="https://gitlab.com/decosterkevin"></a>
        <a class="fa fa-github" href="https://github.com/decosterkevin"></a>
        <a class="fa fa-medium" href="https://medium.com/@decoster.kevin"></a>
        <a class="fa fa-envelope" href="mailto:kevin@decoster.io"></a>
      </div>
    </div>
  </div>


  <script src="javascripts/three.min.js"></script>
  <link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
  <script src="javascripts/WebGL.js"></script>
  <script src="javascripts/stats.min.js"></script>

  <script type="x-shader/x-vertex" id="vertexshader">

			attribute float scale;

			void main() {

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = scale * ( 400.0 / - mvPosition.z ) * 0.7;

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

  <script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;

			void main() {

				if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;

				gl_FragColor = vec4( color, 1.0 );

			}

		</script>

  <script>

    if (WEBGL.isWebGLAvailable() === false) {

      document.body.appendChild(WEBGL.getWebGLErrorMessage());

    }

    var SEPARATION = 100, AMOUNTX = 200, AMOUNTY = 200;

    var container, stats;
    var camera, scene, renderer;

    var particles, count = 0;

    var mouseX = 200, mouseY = -400;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    init();
    animate();

    function init() {

      container = document.getElementById('back');

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.z = 1000;

      scene = new THREE.Scene();

      //

      var numParticles = AMOUNTX * AMOUNTY;

      var positions = new Float32Array(numParticles * 3);
      var scales = new Float32Array(numParticles);

      var i = 0, j = 0;

      for (var ix = 0; ix < AMOUNTX; ix++) {

        for (var iy = 0; iy < AMOUNTY; iy++) {

          positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2); // x
          positions[i + 1] = 0; // y
          positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2); // z

          scales[j] = 1;

          i += 3;
          j++;

        }

      }

      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.addAttribute('scale', new THREE.BufferAttribute(scales, 1));

      var material = new THREE.ShaderMaterial({

        uniforms: {
          color: { value: new THREE.Color(0xffffff) },
        },
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent

      });

      //

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      //

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      // document.addEventListener( 'mousemove', onDocumentMouseMove, false );
      // document.addEventListener( 'touchstart', onDocumentTouchStart, false );
      // document.addEventListener( 'touchmove', onDocumentTouchMove, false );

      //

      window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    //

    function onDocumentMouseMove(event) {

      mouseX = event.clientX - windowHalfX;
      mouseY = event.clientY - windowHalfY;

    }

    function onDocumentTouchStart(event) {

      if (event.touches.length === 1) {

        event.preventDefault();

        mouseX = event.touches[0].pageX - windowHalfX;
        mouseY = event.touches[0].pageY - windowHalfY;

      }

    }

    function onDocumentTouchMove(event) {

      if (event.touches.length === 1) {

        event.preventDefault();

        mouseX = event.touches[0].pageX - windowHalfX;
        mouseY = event.touches[0].pageY - windowHalfY;

      }

    }

    //

    function animate() {

      requestAnimationFrame(animate);

      render();
      // stats.update();

    }

    function render() {

      camera.position.x += (mouseX - camera.position.x) * .05;
      camera.position.y += (- mouseY - camera.position.y) * .05;
      camera.lookAt(scene.position);

      var positions = particles.geometry.attributes.position.array;
      var scales = particles.geometry.attributes.scale.array;

      var i = 0, j = 0;
      var ampl = 50;
      for (var ix = 0; ix < AMOUNTX; ix++) {

        for (var iy = 0; iy < AMOUNTY; iy++) {

          positions[i + 1] = (Math.sin((ix + count) * 0.3) * ampl) +
            (Math.sin((iy + count) * 0.5) * ampl);

          scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 8 +
            (Math.sin((iy + count) * 0.5) + 1) * 8;

          i += 3;
          j++;

        }

      }

      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.scale.needsUpdate = true;

      renderer.render(scene, camera);

      count += 0.1;

    }

  </script>
</body>

</html>